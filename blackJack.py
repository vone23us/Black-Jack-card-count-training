# BLACKJACK: Given three integers between 1 and 11, if their sum is less than or equal to 21, return their sum.# If their sum exceeds 21 and there's an eleven, reduce the total sum by 10.# Finally, if the sum (even after adjustment) exceeds 21, return 'BUST'# HI LO COUNT STRATEGY. The purpose of this program is to teach people how to count cards in the game of Black Jack.# It will also be a training tool so that any user can become proficient at counting cards. The strategy we will use is# called Hi-Lo. We will start by getting the running count. Each card value in the deck is assigned a number.# 10 , j, q, k, a == -1 to count. 2, 3, 4, 5, 6 == count value of +1. 7 8 9 have no value.# As cards are dealt out, a card counting layer must do the math according to each card.# If a string of cards is dealt as follows: 10, J, 3,5,Q then the player determines the value as -1, -1, +1, +1, -1 for# a total value of -1. You must begin the card count after the deck is shuffled with the first card tha is dealt.# The larger the count becomes as you count cards, the more large cards remain in the deck.# If the count is far into the negatives then this means that many of the 10 value cards and aces already been dealt,# and many small cards remain in the deck.# Future development: set up a tracker that takes in a base line of player performance before the use of the program.#                       this way when we can track the users development as he/she becomes more skilled in HI-lo count.#                       set up a top score list to be shared with all users.#  Things we need:##   phase 1: basic functionality##   1: Deck of 52 cards:#       x must be able to have up to 5 decks#       x needs to handle face cards.#       x needs to have 4 suits.#       x logic for Ace = 11 0r 1#       x shuffle##   2: Game rules:#      x closest hand to or on 21 wins game or push if both player and dealer have the same number.#      x Win lose logic both for dealer and player.##   3: Dealer rules:#      x stand on 17#      x hit on anything under 17##   4: player rules:#      x hit, stand##   phase 2: Advanced strategies#       handle situation when the deck runs out of cards#       betting#       repeat play until out of money or player quits.#       start out with set amount of money, or let the user set the starting amount.#       double down#       split#       then start again with the same deck (pop out cards from deck after dealt)#       set up a function to continue playing with the same number of decks from first selection.import random# -----------------------------------------------------------------------------# DEFINE FUNCTIONS / PROGRAM RULES# -----------------------------------------------------------------------------def get_deck():    return [['2♥', 2], ['2♣', 2], ['2♠', 2], ['2♦', 2],            ['3♥', 3], ['3♣', 3], ['3♠', 3], ['3♦', 3],            ['4♥', 4], ['4♣', 4], ['4♠', 4], ['4♦', 4],            ['5♥', 5], ['5♣', 5], ['5♠', 5], ['5♦', 5],            ['6♥', 6], ['6♣', 6], ['6♠', 6], ['6♦', 6],            ['7♥', 7], ['7♣', 7], ['7♠', 7], ['7♦', 7],            ['8♥', 8], ['8♣', 8], ['8♠', 8], ['8♦', 8],            ['9♥', 9], ['9♣', 9], ['9♠', 9], ['9♦', 9],            ['10♥', 10], ['10♣', 10], ['10♠', 10], ['10♦', 10],            ['J♥', 10], ['J♣', 10], ['J♠', 10], ['J♦', 10],            ['Q♥', 10], ['Q♣', 10], ['Q♠', 10], ['Q♦', 10],            ['K♥', 10], ['K♣', 10], ['K♠', 10], ['K♦', 10],            ['A♥', 11], ['A♣', 11], ['A♠', 11], ['A♦', 11]]def get_decks(number_of_decks):    _decks = []    for num in range(number_of_decks):        _decks += get_deck()    return _decksdef print_cards(player_name, cards):    print(player_name + ': ', end='')    for card in cards:        print(card[0] + ' ', end='')    print(' == ' + str(cards_total(cards)))def cards_total(cards):    total = 0    for card in cards:        total += card[1]    # if the total is greater than 21, then check for As    # For each A found, then deduct 10 until the total is below 21.    if total > 21:        for card in cards:            if (card[0] == 'A♥' or card[0] == 'A♣' or card[0] == 'A♠' or card[0] == 'A♦') and total > 21:                total -= 10    return totaldef check_winners(player1_cards, dealer_cards):    if cards_total(player1_cards) > 21:        print("Bust... You Lose")    elif cards_total(dealer_cards) > 21:        print('Dealer Busted, You WIN!')    elif cards_total(player1_cards) < cards_total(dealer_cards):        print('Dealer Wins!')    elif cards_total(player1_cards) > cards_total(dealer_cards):        print('You WIN!')    elif cards_total(player1_cards) == cards_total(dealer_cards):        print('Push!')    # todo when dealer total is = to player total on the deal, and player stands.if the dealer did not bust.    # todo the program used the push outcome instead of the dealer wins outcome,def check_for_blackjack(cards):    return cards_total(cards) == 21def play_round(deck):    # DEAL: Player 1    player1_cards = []    player1_cards.append(deck.pop(0))    # todo there was a (cards) instead of (0) next to .pop. this was causing the program to crash. why?    print_cards('Player 1', player1_cards)    # DEAL: Dealer (hide)    dealer_cards = []    dealer_cards.append(deck.pop(0))    # DEAL: Player 1    player1_cards.append(deck.pop(0))    print_cards('Player 1', player1_cards)    # DEAL: Dealer (show)    dealer_cards.append(deck.pop(0))    print_cards('Dealer ', dealer_cards[1:])    # todo we have to hide the first card and show the second on the dealer. according to regulation rules.    # Player Options (hit or stand)    # offer the player 1 options to hit or stand (FUTURE: betting)    # If the player gets 21, program stands the closes the loop.    print()    # DEAL: Player 1    while cards_total(player1_cards) < 22:        if check_for_blackjack(player1_cards):            print('Player1 has 21!')            break        player1_option = input('(H)it or (S)tand? ')        print()        if 'h' == player1_option.lower():            player1_cards.append(deck.pop(0))            print_cards('Player 1', player1_cards)            print()        elif 's' == player1_option.lower():            print('Player 1 Stands on ' + str(cards_total(player1_cards)))            print()            break    # DEAL: Dealer    print_cards('Dealer  ', dealer_cards)    while cards_total(dealer_cards) <= 16:        dealer_cards.append(deck.pop(0))        print_cards('Dealer  ', dealer_cards)    check_winners(player1_cards, dealer_cards)    print()def is_play_another_round(cards):    # todo this was another bug i fixed but not sure how.    # todo the game will not work with out it, but it seems to be doing nothing.    player1_option = input('Play another round? (Y)es or (N)o? ')    if 'y' == player1_option.lower():        return True    return False    # if so,    #    then display a message stating a reshuffle    #    return get_deck(count)    # if not, then just return the deck that was given in the parametersdef run():    # Generate the deck    training_deck_count = input('How many Decks will you train with? ')    deck = get_decks(int(training_deck_count))    random.shuffle(deck)    print()    round_count = 1    # Kickoff the game    print('Round ', str(round_count))    play_round(deck)    # Play more rounds?    while is_play_another_round(deck):        round_count += 1        print('Round ', str(round_count))        play_round(deck)# -----------------------------------------------------------------------------# GAME START# -----------------------------------------------------------------------------run()